var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _VFXPlayer_instances, _VFXPlayer_opts, _VFXPlayer_canvas, _VFXPlayer_renderer, _VFXPlayer_camera, _VFXPlayer_copyPass, _VFXPlayer_postEffectPass, _VFXPlayer_postEffectTarget, _VFXPlayer_postEffectUniformGenerators, _VFXPlayer_playRequest, _VFXPlayer_pixelRatio, _VFXPlayer_elements, _VFXPlayer_initTime, _VFXPlayer_textureLoader, _VFXPlayer_viewport, _VFXPlayer_viewportInner, _VFXPlayer_canvasSize, _VFXPlayer_paddingX, _VFXPlayer_paddingY, _VFXPlayer_mouseX, _VFXPlayer_mouseY, _VFXPlayer_isRenderingToCanvas, _VFXPlayer_scrollBarSize, _VFXPlayer_getScrollBarSize, _VFXPlayer_updateCanvasSize, _VFXPlayer_resize, _VFXPlayer_mousemove, _VFXPlayer_rerenderTextElement, _VFXPlayer_playLoop, _VFXPlayer_hitTest, _VFXPlayer_getShader, _VFXPlayer_getGLSLVersion, _VFXPlayer_render, _VFXPlayer_setOffset, _VFXPlayer_setupPostEffectTarget;
import * as THREE from "three";
import { Backbuffer } from "./backbuffer.js";
import { DEFAULT_VERTEX_SHADER, DEFAULT_VERTEX_SHADER_100, shaders, } from "./constants.js";
import { CopyPass } from "./copy-pass.js";
import dom2canvas from "./dom-to-canvas.js";
import GIFData from "./gif.js";
import { getGLRect, rectToGLRect } from "./gl-rect.js";
import { PostEffectPass } from "./post-effect-pass.js";
import { MARGIN_ZERO, createMargin, createRect, getIntersection, growRect, toRect, } from "./rect.js";
const gifFor = new Map();
/**
 * @internal
 */
export class VFXPlayer {
    constructor(opts, canvas) {
        _VFXPlayer_instances.add(this);
        _VFXPlayer_opts.set(this, void 0);
        _VFXPlayer_canvas.set(this, void 0);
        _VFXPlayer_renderer.set(this, void 0);
        _VFXPlayer_camera.set(this, void 0);
        _VFXPlayer_copyPass.set(this, void 0);
        _VFXPlayer_postEffectPass.set(this, void 0);
        _VFXPlayer_postEffectTarget.set(this, void 0);
        _VFXPlayer_postEffectUniformGenerators.set(this, {});
        _VFXPlayer_playRequest.set(this, undefined);
        _VFXPlayer_pixelRatio.set(this, 2);
        _VFXPlayer_elements.set(this, []);
        _VFXPlayer_initTime.set(this, Date.now() / 1000.0);
        _VFXPlayer_textureLoader.set(this, new THREE.TextureLoader());
        _VFXPlayer_viewport.set(this, createRect(0));
        /** Actual viewport without padding */
        _VFXPlayer_viewportInner.set(this, createRect(0));
        _VFXPlayer_canvasSize.set(this, [0, 0]);
        _VFXPlayer_paddingX.set(this, 0);
        _VFXPlayer_paddingY.set(this, 0);
        _VFXPlayer_mouseX.set(this, 0);
        _VFXPlayer_mouseY.set(this, 0);
        _VFXPlayer_isRenderingToCanvas.set(this, new WeakMap());
        _VFXPlayer_scrollBarSize.set(this, void 0);
        _VFXPlayer_resize.set(this, () => __awaiter(this, void 0, void 0, function* () {
            if (typeof window !== "undefined") {
                // Update dom2canvas result.
                // Render elements in viewport first, then render elements outside of the viewport.
                for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
                    if (e.type === "text" && e.isInViewport) {
                        const rect = e.element.getBoundingClientRect();
                        if (rect.width !== e.width || rect.height !== e.height) {
                            yield __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, e);
                            e.width = rect.width;
                            e.height = rect.height;
                        }
                    }
                }
                for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
                    if (e.type === "text" && !e.isInViewport) {
                        const rect = e.element.getBoundingClientRect();
                        if (rect.width !== e.width || rect.height !== e.height) {
                            yield __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, e);
                            e.width = rect.width;
                            e.height = rect.height;
                        }
                    }
                }
            }
        }));
        _VFXPlayer_mousemove.set(this, (e) => {
            if (typeof window !== "undefined") {
                __classPrivateFieldSet(this, _VFXPlayer_mouseX, e.clientX, "f");
                __classPrivateFieldSet(this, _VFXPlayer_mouseY, window.innerHeight - e.clientY, "f");
            }
        });
        _VFXPlayer_playLoop.set(this, () => {
            if (this.isPlaying()) {
                this.render();
                __classPrivateFieldSet(this, _VFXPlayer_playRequest, requestAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playLoop, "f")), "f");
            }
        });
        __classPrivateFieldSet(this, _VFXPlayer_opts, opts, "f");
        __classPrivateFieldSet(this, _VFXPlayer_canvas, canvas, "f");
        __classPrivateFieldSet(this, _VFXPlayer_renderer, new THREE.WebGLRenderer({
            canvas,
            alpha: true,
        }), "f");
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").autoClear = false;
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setClearAlpha(0);
        __classPrivateFieldSet(this, _VFXPlayer_pixelRatio, opts.pixelRatio, "f");
        if (typeof window !== "undefined") {
            window.addEventListener("resize", __classPrivateFieldGet(this, _VFXPlayer_resize, "f"));
            window.addEventListener("mousemove", __classPrivateFieldGet(this, _VFXPlayer_mousemove, "f"));
        }
        __classPrivateFieldGet(this, _VFXPlayer_resize, "f").call(this);
        __classPrivateFieldSet(this, _VFXPlayer_camera, new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10), "f");
        __classPrivateFieldGet(this, _VFXPlayer_camera, "f").position.set(0, 0, 1);
        // Setup copyScene
        __classPrivateFieldSet(this, _VFXPlayer_copyPass, new CopyPass(), "f");
        // Setup post effect pass if specified
        if (opts.postEffect) {
            const postEffectShader = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getShader).call(this, opts.postEffect.shader);
            __classPrivateFieldSet(this, _VFXPlayer_postEffectPass, new PostEffectPass(postEffectShader, opts.postEffect.uniforms, opts.postEffect.backbuffer), "f");
            // Store uniform generators for custom uniforms
            if (opts.postEffect.uniforms) {
                for (const [key, value] of Object.entries(opts.postEffect.uniforms)) {
                    if (typeof value === "function") {
                        __classPrivateFieldGet(this, _VFXPlayer_postEffectUniformGenerators, "f")[key] = value;
                    }
                }
            }
        }
    }
    destroy() {
        this.stop();
        if (typeof window !== "undefined") {
            window.removeEventListener("resize", __classPrivateFieldGet(this, _VFXPlayer_resize, "f"));
            window.removeEventListener("mousemove", __classPrivateFieldGet(this, _VFXPlayer_mousemove, "f"));
        }
        // Clean up post effect resources
        if (__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f")) {
            __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f").dispose();
        }
    }
    addElement(element_1) {
        return __awaiter(this, arguments, void 0, function* (element, opts = {}) {
            var _a, _b, _c;
            const shader = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getShader).call(this, opts.shader || "uvGradient");
            const glslVersion = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getGLSLVersion).call(this, opts.glslVersion, shader);
            const domRect = element.getBoundingClientRect();
            const rect = toRect(domRect);
            const [isFullScreen, overflow] = parseOverflowOpts(opts.overflow);
            const rectWithOverflow = growRect(rect, overflow);
            const intersectionOpts = parseIntersectionOpts(opts.intersection);
            const originalOpacity = element.style.opacity === ""
                ? 1
                : Number.parseFloat(element.style.opacity);
            // Create values for element types
            let texture;
            let type;
            let isGif = false;
            if (element instanceof HTMLImageElement) {
                type = "img";
                isGif = !!element.src.match(/\.gif/i);
                if (isGif) {
                    const gif = yield GIFData.create(element.src, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
                    gifFor.set(element, gif);
                    texture = new THREE.Texture(gif.getCanvas());
                }
                else {
                    texture = yield __classPrivateFieldGet(this, _VFXPlayer_textureLoader, "f").loadAsync(element.src);
                }
            }
            else if (element instanceof HTMLVideoElement) {
                texture = new THREE.VideoTexture(element);
                type = "video";
            }
            else if (element instanceof HTMLCanvasElement) {
                texture = new THREE.CanvasTexture(element);
                type = "canvas";
            }
            else {
                const canvas = yield dom2canvas(element, originalOpacity);
                texture = new THREE.CanvasTexture(canvas);
                type = "text";
            }
            const [wrapS, wrapT] = parseWrap(opts.wrap);
            texture.wrapS = wrapS;
            texture.wrapT = wrapT;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBAFormat;
            texture.needsUpdate = true;
            const autoCrop = (_a = opts.autoCrop) !== null && _a !== void 0 ? _a : true;
            // Hide original element
            if (opts.overlay === true) {
                /* Overlay mode. Do not hide the element */
            }
            else if (typeof opts.overlay === "number") {
                element.style.setProperty("opacity", opts.overlay.toString());
            }
            else {
                const opacity = type === "video" ? "0.0001" : "0"; // don't hide video element completely to prevent jank frames
                element.style.setProperty("opacity", opacity.toString());
            }
            const uniforms = {
                src: { value: texture },
                resolution: {
                    value: new THREE.Vector2(),
                },
                offset: { value: new THREE.Vector2() },
                time: { value: 0.0 },
                enterTime: { value: -1.0 },
                leaveTime: { value: -1.0 },
                mouse: { value: new THREE.Vector2() },
                intersection: { value: 0.0 },
                viewport: { value: new THREE.Vector4() },
                autoCrop: { value: autoCrop },
            };
            const uniformGenerators = {};
            if (opts.uniforms !== undefined) {
                const keys = Object.keys(opts.uniforms);
                for (const key of keys) {
                    const value = opts.uniforms[key];
                    if (typeof value === "function") {
                        uniforms[key] = {
                            value: value(),
                        };
                        uniformGenerators[key] = value;
                    }
                    else {
                        uniforms[key] = { value };
                    }
                }
            }
            // Backbuffer
            let backbuffer = undefined;
            if (opts.backbuffer) {
                backbuffer = (() => {
                    const bw = (rectWithOverflow.right - rectWithOverflow.left) *
                        __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                    const bh = (rectWithOverflow.bottom - rectWithOverflow.top) *
                        __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                    return new Backbuffer(bw, bh, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
                })();
                uniforms["backbuffer"] = { value: backbuffer.texture };
            }
            const scene = new THREE.Scene();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const vertexShader = glslVersion === "100"
                ? DEFAULT_VERTEX_SHADER_100
                : DEFAULT_VERTEX_SHADER;
            const material = new THREE.RawShaderMaterial({
                vertexShader,
                fragmentShader: shader,
                transparent: true,
                uniforms,
                glslVersion,
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            const now = Date.now() / 1000;
            const elem = {
                type,
                element,
                isInViewport: false,
                isInLogicalViewport: false,
                width: domRect.width,
                height: domRect.height,
                scene,
                mesh,
                uniforms,
                uniformGenerators,
                startTime: now,
                enterTime: now,
                leaveTime: Number.NEGATIVE_INFINITY,
                release: (_b = opts.release) !== null && _b !== void 0 ? _b : Number.POSITIVE_INFINITY,
                isGif,
                isFullScreen,
                overflow,
                intersection: intersectionOpts,
                originalOpacity,
                zIndex: (_c = opts.zIndex) !== null && _c !== void 0 ? _c : 0,
                backbuffer,
                autoCrop,
            };
            __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_hitTest).call(this, elem, rect, now);
            // Insert element and sort elements by z-index.
            // Array.prototype.sort is stable sort, so the elements with same z
            // will be rendered by the order they are added to VFX.
            __classPrivateFieldGet(this, _VFXPlayer_elements, "f").push(elem);
            __classPrivateFieldGet(this, _VFXPlayer_elements, "f").sort((a, b) => a.zIndex - b.zIndex);
        });
    }
    removeElement(element) {
        const i = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").findIndex((e) => e.element === element);
        if (i !== -1) {
            const e = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").splice(i, 1)[0];
            // Recover the original state
            element.style.setProperty("opacity", e.originalOpacity.toString());
        }
    }
    updateTextElement(element) {
        const i = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").findIndex((e) => e.element === element);
        if (i !== -1) {
            return __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, __classPrivateFieldGet(this, _VFXPlayer_elements, "f")[i]);
        }
        // Do nothing if the element is not found
        // This happens when addElement is still processing
        return Promise.resolve();
    }
    updateCanvasElement(element) {
        const e = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").find((e) => e.element === element);
        if (e) {
            const oldTexture = e.uniforms["src"].value;
            const texture = new THREE.CanvasTexture(element);
            texture.wrapS = oldTexture.wrapS;
            texture.wrapT = oldTexture.wrapT;
            e.uniforms["src"].value = texture;
            oldTexture.dispose();
        }
    }
    isPlaying() {
        return __classPrivateFieldGet(this, _VFXPlayer_playRequest, "f") !== undefined;
    }
    play() {
        if (!this.isPlaying()) {
            __classPrivateFieldSet(this, _VFXPlayer_playRequest, requestAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playLoop, "f")), "f");
        }
    }
    stop() {
        if (__classPrivateFieldGet(this, _VFXPlayer_playRequest, "f") !== undefined) {
            cancelAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playRequest, "f"));
            __classPrivateFieldSet(this, _VFXPlayer_playRequest, undefined, "f");
        }
    }
    render() {
        var _a;
        const now = Date.now() / 1000;
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").clear();
        // This must done every frame because iOS Safari doesn't fire
        // window resize event while the address bar is transforming.
        __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_updateCanvasSize).call(this);
        const viewportWidth = __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").right - __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").left;
        const viewportHeight = __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").bottom - __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").top;
        const viewportGlRect = getGLRect(0, 0, viewportWidth, viewportHeight);
        // Setup post effect render target if needed
        const shouldUsePostEffect = __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f") !== undefined;
        if (shouldUsePostEffect) {
            __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_setupPostEffectTarget).call(this, viewportWidth, viewportHeight);
            // Clear the post effect target once at the beginning
            if (__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f")) {
                __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setRenderTarget(__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f"));
                __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").clear();
                __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setRenderTarget(null);
            }
        }
        for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
            const domRect = e.element.getBoundingClientRect();
            const rect = toRect(domRect);
            const hit = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_hitTest).call(this, e, rect, now);
            if (!hit.isVisible) {
                continue;
            }
            // Update uniforms
            e.uniforms["time"].value = now - e.startTime;
            e.uniforms["resolution"].value.x = domRect.width * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
            e.uniforms["resolution"].value.y =
                domRect.height * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
            e.uniforms["mouse"].value.x = __classPrivateFieldGet(this, _VFXPlayer_mouseX, "f") * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
            e.uniforms["mouse"].value.y = __classPrivateFieldGet(this, _VFXPlayer_mouseY, "f") * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
            for (const [key, gen] of Object.entries(e.uniformGenerators)) {
                e.uniforms[key].value = gen();
            }
            // Update GIF / video
            (_a = gifFor.get(e.element)) === null || _a === void 0 ? void 0 : _a.update();
            if (e.type === "video" || e.isGif) {
                e.uniforms["src"].value.needsUpdate = true;
            }
            const glRect = rectToGLRect(rect, viewportHeight, __classPrivateFieldGet(this, _VFXPlayer_paddingX, "f"), __classPrivateFieldGet(this, _VFXPlayer_paddingY, "f"));
            const glRectWithOverflow = rectToGLRect(hit.rectWithOverflow, viewportHeight, __classPrivateFieldGet(this, _VFXPlayer_paddingX, "f"), __classPrivateFieldGet(this, _VFXPlayer_paddingY, "f"));
            if (e.backbuffer) {
                // Update backbuffer
                e.uniforms["backbuffer"].value = e.backbuffer.texture;
                if (e.isFullScreen) {
                    e.backbuffer.resize(viewportWidth, viewportHeight);
                    // Render to backbuffer
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_setOffset).call(this, e, glRect.x, glRect.y);
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, e.scene, e.backbuffer.target, viewportGlRect, e.uniforms);
                    e.backbuffer.swap();
                    // Render to canvas
                    __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").setUniforms(e.backbuffer.texture, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), viewportGlRect);
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").scene, shouldUsePostEffect
                        ? __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f") || null
                        : null, viewportGlRect, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").uniforms);
                }
                else {
                    e.backbuffer.resize(glRectWithOverflow.w, glRectWithOverflow.h);
                    // Render to backbuffer
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_setOffset).call(this, e, e.overflow.left, e.overflow.bottom);
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, e.scene, e.backbuffer.target, e.backbuffer.getViewport(), e.uniforms);
                    e.backbuffer.swap();
                    // Render to canvas
                    __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").setUniforms(e.backbuffer.texture, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), glRectWithOverflow);
                    __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").scene, shouldUsePostEffect
                        ? __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f") || null
                        : null, glRectWithOverflow, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").uniforms);
                }
            }
            else {
                // Render to canvas
                __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_setOffset).call(this, e, glRect.x, glRect.y);
                __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, e.scene, shouldUsePostEffect ? __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f") || null : null, e.isFullScreen ? viewportGlRect : glRectWithOverflow, e.uniforms);
            }
        }
        // Apply post effect if enabled
        if (shouldUsePostEffect &&
            __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f") &&
            __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f")) {
            __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").setUniforms(__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f").texture, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), viewportGlRect, now - __classPrivateFieldGet(this, _VFXPlayer_initTime, "f"), __classPrivateFieldGet(this, _VFXPlayer_mouseX, "f"), __classPrivateFieldGet(this, _VFXPlayer_mouseY, "f"));
            // Update custom uniforms
            __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").updateCustomUniforms(__classPrivateFieldGet(this, _VFXPlayer_postEffectUniformGenerators, "f"));
            // Handle backbuffer rendering
            if (__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer) {
                // Update backbuffer texture reference (previous frame)
                __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").uniforms.backbuffer.value =
                    __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer.texture;
                // Render post effect to backbuffer target
                __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").scene, __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer.target, viewportGlRect, __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").uniforms);
                // Swap backbuffer immediately after rendering
                __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer.swap();
                // Copy from backbuffer to canvas
                __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").setUniforms(__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer.texture, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), viewportGlRect);
                __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").scene, null, viewportGlRect, __classPrivateFieldGet(this, _VFXPlayer_copyPass, "f").uniforms);
            }
            else {
                // Render post effect directly to canvas
                __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_render).call(this, __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").scene, null, viewportGlRect, __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").uniforms);
            }
        }
    }
}
_VFXPlayer_opts = new WeakMap(), _VFXPlayer_canvas = new WeakMap(), _VFXPlayer_renderer = new WeakMap(), _VFXPlayer_camera = new WeakMap(), _VFXPlayer_copyPass = new WeakMap(), _VFXPlayer_postEffectPass = new WeakMap(), _VFXPlayer_postEffectTarget = new WeakMap(), _VFXPlayer_postEffectUniformGenerators = new WeakMap(), _VFXPlayer_playRequest = new WeakMap(), _VFXPlayer_pixelRatio = new WeakMap(), _VFXPlayer_elements = new WeakMap(), _VFXPlayer_initTime = new WeakMap(), _VFXPlayer_textureLoader = new WeakMap(), _VFXPlayer_viewport = new WeakMap(), _VFXPlayer_viewportInner = new WeakMap(), _VFXPlayer_canvasSize = new WeakMap(), _VFXPlayer_paddingX = new WeakMap(), _VFXPlayer_paddingY = new WeakMap(), _VFXPlayer_mouseX = new WeakMap(), _VFXPlayer_mouseY = new WeakMap(), _VFXPlayer_isRenderingToCanvas = new WeakMap(), _VFXPlayer_scrollBarSize = new WeakMap(), _VFXPlayer_resize = new WeakMap(), _VFXPlayer_mousemove = new WeakMap(), _VFXPlayer_playLoop = new WeakMap(), _VFXPlayer_instances = new WeakSet(), _VFXPlayer_getScrollBarSize = function _VFXPlayer_getScrollBarSize() {
    if (__classPrivateFieldGet(this, _VFXPlayer_scrollBarSize, "f") === undefined) {
        const div = document.createElement("div");
        div.style.visibility = "hidden";
        div.style.overflow = "scroll"; // Force scrollbar
        div.style.position = "absolute";
        document.body.appendChild(div);
        const scrollbarSize = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
        __classPrivateFieldSet(this, _VFXPlayer_scrollBarSize, scrollbarSize, "f");
    }
    return __classPrivateFieldGet(this, _VFXPlayer_scrollBarSize, "f");
}, _VFXPlayer_updateCanvasSize = function _VFXPlayer_updateCanvasSize() {
    var _a, _b;
    if (typeof window === "undefined") {
        return;
    }
    // Get the window size without scroll bar
    const wrapper = __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").parentElement;
    const wrapperParent = wrapper.parentElement;
    const ownerWindow = (_b = (_a = wrapper.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.window) !== null && _b !== void 0 ? _b : window;
    const scrollBarWidth = wrapperParent.scrollHeight > wrapperParent.clientHeight
        ? __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getScrollBarSize).call(this)
        : 0;
    const scrollBarHeight = wrapperParent.scrollWidth > wrapperParent.clientWidth
        ? __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getScrollBarSize).call(this)
        : 0;
    const width = ownerWindow.innerWidth - scrollBarWidth;
    const height = ownerWindow.innerHeight - scrollBarHeight;
    const scrollX = window.scrollX;
    const scrollY = window.scrollY;
    let paddingX;
    let paddingY;
    if (__classPrivateFieldGet(this, _VFXPlayer_opts, "f").fixedCanvas) {
        paddingY = 0;
        paddingX = 0;
    }
    else {
        // Clamp padding so that the canvas doesn't cause overflow
        const maxPaddingX = wrapper.scrollWidth - (scrollX + width);
        const maxPaddingY = wrapper.scrollHeight - (scrollY + height);
        paddingX = clamp(width * __classPrivateFieldGet(this, _VFXPlayer_opts, "f").scrollPadding[0], 0, maxPaddingX);
        paddingY = clamp(height * __classPrivateFieldGet(this, _VFXPlayer_opts, "f").scrollPadding[1], 0, maxPaddingY);
    }
    const widthWithPadding = width + paddingX * 2;
    const heightWithPadding = height + paddingY * 2;
    if (widthWithPadding !== __classPrivateFieldGet(this, _VFXPlayer_canvasSize, "f")[0] ||
        heightWithPadding !== __classPrivateFieldGet(this, _VFXPlayer_canvasSize, "f")[1]) {
        __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").width = widthWithPadding;
        __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").height = heightWithPadding;
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setSize(widthWithPadding, heightWithPadding);
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setPixelRatio(__classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
        __classPrivateFieldSet(this, _VFXPlayer_viewport, createRect({
            top: -paddingY,
            left: -paddingX,
            right: widthWithPadding,
            bottom: heightWithPadding,
        }), "f");
        __classPrivateFieldSet(this, _VFXPlayer_viewportInner, createRect({
            top: 0,
            left: 0,
            right: width,
            bottom: height,
        }), "f");
        __classPrivateFieldSet(this, _VFXPlayer_canvasSize, [widthWithPadding, heightWithPadding], "f");
        __classPrivateFieldSet(this, _VFXPlayer_paddingX, paddingX, "f");
        __classPrivateFieldSet(this, _VFXPlayer_paddingY, paddingY, "f");
    }
    // Sync scroll
    if (!__classPrivateFieldGet(this, _VFXPlayer_opts, "f").fixedCanvas) {
        __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").style.setProperty("transform", `translate(${scrollX - paddingX}px, ${scrollY - paddingY}px)`);
    }
}, _VFXPlayer_rerenderTextElement = function _VFXPlayer_rerenderTextElement(e) {
    return __awaiter(this, void 0, void 0, function* () {
        if (__classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").get(e.element)) {
            return;
        }
        __classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").set(e.element, true);
        try {
            const oldTexture = e.uniforms["src"].value;
            const oldCanvas = oldTexture.image;
            const canvas = yield dom2canvas(e.element, e.originalOpacity, oldCanvas);
            if (canvas.width === 0 || canvas.width === 0) {
                throw "omg";
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = oldTexture.wrapS;
            texture.wrapT = oldTexture.wrapT;
            e.uniforms["src"].value = texture;
            oldTexture.dispose();
        }
        catch (e) {
            console.error(e);
        }
        __classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").set(e.element, false);
    });
}, _VFXPlayer_hitTest = function _VFXPlayer_hitTest(e, rect, now) {
    const rectWithOverflow = growRect(rect, e.overflow);
    const isInViewport = e.isFullScreen ||
        isRectInViewport(__classPrivateFieldGet(this, _VFXPlayer_viewportInner, "f"), rectWithOverflow);
    const viewportWithMargin = growRect(__classPrivateFieldGet(this, _VFXPlayer_viewportInner, "f"), e.intersection.rootMargin);
    const intersection = getIntersection(viewportWithMargin, rect);
    const isInLogicalViewport = e.isFullScreen ||
        checkIntersection(viewportWithMargin, rect, intersection, e.intersection.threshold);
    // Update transition timing
    if (!e.isInLogicalViewport && isInLogicalViewport /* out -> in */) {
        e.enterTime = now;
        e.leaveTime = Number.POSITIVE_INFINITY;
    }
    if (e.isInLogicalViewport && !isInLogicalViewport /* in -> out */) {
        e.leaveTime = now;
    }
    e.isInViewport = isInViewport;
    e.isInLogicalViewport = isInLogicalViewport;
    // Quit if the element has left and the transition has ended
    const isVisible = isInViewport && now - e.leaveTime <= e.release;
    if (isVisible) {
        e.uniforms["intersection"].value = intersection;
        e.uniforms["enterTime"].value = now - e.enterTime;
        e.uniforms["leaveTime"].value = now - e.leaveTime;
    }
    return { isVisible, intersection, rectWithOverflow };
}, _VFXPlayer_getShader = function _VFXPlayer_getShader(shaderNameOrCode) {
    if (shaderNameOrCode in shaders) {
        return shaders[shaderNameOrCode];
    }
    else {
        return shaderNameOrCode; // Assume that the given string is a valid shader code
    }
}, _VFXPlayer_getGLSLVersion = function _VFXPlayer_getGLSLVersion(opt, shader) {
    if (opt) {
        return opt;
    }
    if (shader.includes("out vec4")) {
        return "300 es";
    }
    if (shader.includes("gl_FragColor")) {
        return "100";
    }
    throw `VFX-JS error: Cannot detect GLSL version of the shader.\n\nOriginal shader:\n${shader}`;
}, _VFXPlayer_render = function _VFXPlayer_render(scene, target, rect, uniforms) {
    __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setRenderTarget(target);
    // Only clear if target is not the post effect target (which is cleared once at the beginning)
    if (target !== null && target !== __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f")) {
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").clear();
    }
    __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setViewport(rect.x, rect.y, rect.w, rect.h);
    // Set viewport uniform if passed and exists
    if (uniforms["viewport"]) {
        uniforms["viewport"].value.set(rect.x * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), rect.y * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), rect.w * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"), rect.h * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
    }
    try {
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").render(scene, __classPrivateFieldGet(this, _VFXPlayer_camera, "f"));
    }
    catch (e) {
        console.error(e);
    }
}, _VFXPlayer_setOffset = function _VFXPlayer_setOffset(e, x, y) {
    e.uniforms["offset"].value.x = x * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
    e.uniforms["offset"].value.y = y * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
}, _VFXPlayer_setupPostEffectTarget = function _VFXPlayer_setupPostEffectTarget(width, height) {
    const targetWidth = width * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
    const targetHeight = height * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
    if (!__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f") ||
        __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f").width !== targetWidth ||
        __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f").height !== targetHeight) {
        if (__classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f")) {
            __classPrivateFieldGet(this, _VFXPlayer_postEffectTarget, "f").dispose();
        }
        __classPrivateFieldSet(this, _VFXPlayer_postEffectTarget, new THREE.WebGLRenderTarget(targetWidth, targetHeight, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
        }), "f");
    }
    // Initialize/resize post effect backbuffer if needed
    if (__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f")) {
        if (__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").uniforms.backbuffer &&
            !__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer) {
            __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").initializeBackbuffer(width, height, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
        }
        else if (__classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").backbuffer) {
            __classPrivateFieldGet(this, _VFXPlayer_postEffectPass, "f").resizeBackbuffer(width, height);
        }
    }
};
/**
 * Returns if the given rects intersect.
 * It returns true when the rects are adjacent (= intersection ratio is 0).
 */
export function isRectInViewport(viewport, rect) {
    return (rect.left <= viewport.right &&
        rect.right >= viewport.left &&
        rect.top <= viewport.bottom &&
        rect.bottom >= viewport.top);
}
export function checkIntersection(viewport, rect, intersection, threshold) {
    if (threshold === 0) {
        // if threshold === 0, consider adjacent rects to be intersecting.
        return isRectInViewport(viewport, rect);
    }
    else {
        return intersection >= threshold;
    }
}
export function parseOverflowOpts(overflow) {
    if (overflow === true) {
        return [true, MARGIN_ZERO];
    }
    if (overflow === undefined) {
        return [false, MARGIN_ZERO];
    }
    return [false, createMargin(overflow)];
}
export function parseIntersectionOpts(intersectionOpts) {
    var _a, _b;
    const threshold = (_a = intersectionOpts === null || intersectionOpts === void 0 ? void 0 : intersectionOpts.threshold) !== null && _a !== void 0 ? _a : 0;
    const rootMargin = createMargin((_b = intersectionOpts === null || intersectionOpts === void 0 ? void 0 : intersectionOpts.rootMargin) !== null && _b !== void 0 ? _b : 0);
    return {
        threshold,
        rootMargin,
    };
}
function parseWrapSingle(wrapOpt) {
    if (wrapOpt === "repeat") {
        return THREE.RepeatWrapping;
    }
    else if (wrapOpt === "mirror") {
        return THREE.MirroredRepeatWrapping;
    }
    else {
        return THREE.ClampToEdgeWrapping;
    }
}
function parseWrap(wrapOpt) {
    if (!wrapOpt) {
        return [THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping];
    }
    if (Array.isArray(wrapOpt)) {
        return [parseWrapSingle(wrapOpt[0]), parseWrapSingle(wrapOpt[1])];
    }
    else {
        const w = parseWrapSingle(wrapOpt);
        return [w, w];
    }
}
function clamp(x, xmin, xmax) {
    return Math.max(xmin, Math.min(xmax, x));
}
//# sourceMappingURL=vfx-player.js.map