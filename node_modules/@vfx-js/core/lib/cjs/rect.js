"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MARGIN_ZERO = exports.RECT_ZERO = void 0;
exports.createMargin = createMargin;
exports.createRect = createRect;
exports.toRect = toRect;
exports.growRect = growRect;
exports.shrinkRect = shrinkRect;
exports.getIntersection = getIntersection;
/** @internal */
function tetra(top, right, bottom, left) {
    return { top, right, bottom, left };
}
/** @internal */
function createTetra(r) {
    var _a, _b, _c, _d;
    if (typeof r === "number") {
        return {
            top: r,
            right: r,
            bottom: r,
            left: r,
        };
    }
    if (Array.isArray(r)) {
        return {
            top: r[0],
            right: r[1],
            bottom: r[2],
            left: r[3],
        };
    }
    return {
        top: (_a = r.top) !== null && _a !== void 0 ? _a : 0,
        right: (_b = r.right) !== null && _b !== void 0 ? _b : 0,
        bottom: (_c = r.bottom) !== null && _c !== void 0 ? _c : 0,
        left: (_d = r.left) !== null && _d !== void 0 ? _d : 0,
    };
}
exports.RECT_ZERO = tetra(0, 0, 0, 0);
function createMargin(r) {
    return createTetra(r);
}
exports.MARGIN_ZERO = tetra(0, 0, 0, 0);
function createRect(r) {
    return createTetra(r);
}
function toRect(r) {
    return {
        top: r.top,
        right: r.right,
        bottom: r.bottom,
        left: r.left,
    };
}
function growRect(a, b) {
    return {
        top: a.top - b.top,
        right: a.right + b.right,
        bottom: a.bottom + b.bottom,
        left: a.left - b.left,
    };
}
function shrinkRect(a, b) {
    return {
        top: a.top + b.top,
        right: a.right - b.right,
        bottom: a.bottom - b.bottom,
        left: a.left + b.left,
    };
}
function clamp(x, xmin, xmax) {
    return Math.min(Math.max(x, xmin), xmax);
}
/**
 * Calculate the ratio of the intersection between two Rect objects.
 * It returns a number between 0 and 1.
 */
function getIntersection(container, target) {
    const targetL = clamp(target.left, container.left, container.right);
    const targetR = clamp(target.right, container.left, container.right);
    const w = (targetR - targetL) / (target.right - target.left);
    const targetT = clamp(target.top, container.top, container.bottom);
    const targetB = clamp(target.bottom, container.top, container.bottom);
    const h = (targetB - targetT) / (target.bottom - target.top);
    return w * h;
}
//# sourceMappingURL=rect.js.map